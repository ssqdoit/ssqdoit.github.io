import{_ as s,c as a,o as i,a5 as n}from"./chunks/framework.DHgPyqoO.js";const e="/assets/1.6e1UHaeW.png",u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"daily/2025/一个好的 Debugging：高效定位 Bug 的实用技巧.md","filePath":"daily/2025/一个好的 Debugging：高效定位 Bug 的实用技巧.md","lastUpdated":null}'),l={name:"daily/2025/一个好的 Debugging：高效定位 Bug 的实用技巧.md"},t=n('<p>最好的代码是没有 Bug 的代码，但最好的程序员是知道如何快速找到 Bug 的程序员。如何高效地定位和解决它们，是每个程序员都需要掌握的技能。下面是介绍一些定位 Bug 的小技巧。</p><h2 id="巧用-git-bisect" tabindex="-1">巧用 Git bisect <a class="header-anchor" href="#巧用-git-bisect" aria-label="Permalink to &quot;巧用 Git bisect&quot;">​</a></h2><h3 id="程序员的噩梦是什么" tabindex="-1">程序员的噩梦是什么？ <a class="header-anchor" href="#程序员的噩梦是什么" aria-label="Permalink to &quot;程序员的噩梦是什么？&quot;">​</a></h3><p>&quot;这个 Bug 上周还没出现，到底是谁改的代码？！&quot;</p><p>在多人开发项目时，难免会出现这种尴尬的情况，但如何在众多的 Commit 中找到已发问题的元凶？以前的我真的遇到过，然后人肉排查，手动通过二分法去找到那条错误的 Commit, 过程很痛苦、因为不仅要分析还要手动记录。</p><p>但 git bisect 可以帮助我们快速定位 bug，告别人肉排查。</p><h3 id="什么是-git-bisect" tabindex="-1">什么是 git bisect <a class="header-anchor" href="#什么是-git-bisect" aria-label="Permalink to &quot;什么是 git bisect&quot;">​</a></h3><p>git bisect 是 Git 提供的一个用于快速定位代码库中引入错误（Bug）的特定提交的工具。基于二分查找算法，通过自动在提交历史中切换版本，帮助开发者高效缩小问题范围，最终找到导致问题的第一个错误提交。</p><h3 id="实操步骤" tabindex="-1">实操步骤: <a class="header-anchor" href="#实操步骤" aria-label="Permalink to &quot;实操步骤:&quot;">​</a></h3><blockquote><p>如下图的 Git 可视化工具显示的定位记录</p></blockquote><p><img src="'+e+`" alt="img"></p><h4 id="启动-侦探模式" tabindex="-1">启动&quot;侦探模式&quot; <a class="header-anchor" href="#启动-侦探模式" aria-label="Permalink to &quot;启动&quot;侦探模式&quot;&quot;">​</a></h4><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          # 进入bisect时空隧道  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bad</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 标记当前版本有问题  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> good</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> b31b261</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 标记已知正常的提交（替换为你的正常commit哈希）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="测试当前版本" tabindex="-1">测试当前版本 <a class="header-anchor" href="#测试当前版本" aria-label="Permalink to &quot;测试当前版本&quot;">​</a></h4><p>Git 会自动跳转到中间的 Commit ，然后使用脚本 or 单元测试 or 人工测试 判断此时的 Commit 是否有问题</p><p><strong>有问题</strong>：标记为 <code>bad</code></p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bad</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>正常</strong>：标记为 <code>good</code></p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> good</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="重复直到破案" tabindex="-1">重复直到破案 <a class="header-anchor" href="#重复直到破案" aria-label="Permalink to &quot;重复直到破案&quot;">​</a></h4><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[c380b68d90fdcc2f9b9d84858a0da4c66181a028] commit message</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="退出-时空隧道" tabindex="-1">退出&quot;时空隧道&quot; <a class="header-anchor" href="#退出-时空隧道" aria-label="Permalink to &quot;退出&quot;时空隧道&quot;&quot;">​</a></h4><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 回到最初的分支</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="高级用法" tabindex="-1">高级用法 <a class="header-anchor" href="#高级用法" aria-label="Permalink to &quot;高级用法&quot;">​</a></h3><h4 id="执行自动化二分查找" tabindex="-1"><strong>执行自动化二分查找</strong> <a class="header-anchor" href="#执行自动化二分查找" aria-label="Permalink to &quot;**执行自动化二分查找**&quot;">​</a></h4><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 进入 bisect 模式</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 标记当前提交为&quot;坏&quot;（通常是 HEAD）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bad</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 标记已知的&quot;好&quot;提交（替换为你的正常版本哈希）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> good</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> b31b261</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 启动自动化测试脚本</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./test-script.sh</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bisect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 回到最初的分支</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>脚本需要满足以下条件：</p><p><strong>返回值规则</strong>：</p><ul><li><strong>返回 0</strong>：当前提交是&quot;好&quot;的（无 Bug）</li><li><strong>返回非 0</strong>（如 1）：当前提交是&quot;坏&quot;的（有 Bug）</li></ul><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/bin/bash</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 编译代码（可选）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 运行测试（假设项目用 pytest）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pytest</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test_login.py</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 检查测试是否通过</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -eq</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  exit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 测试通过 → 标记为 good</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  exit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 测试失败 → 标记为 bad</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fi</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="橡皮鸭调试法-源于《程序员修炼之道》" tabindex="-1">橡皮鸭调试法 （源于《程序员修炼之道》） <a class="header-anchor" href="#橡皮鸭调试法-源于《程序员修炼之道》" aria-label="Permalink to &quot;橡皮鸭调试法 （源于《程序员修炼之道》）&quot;">​</a></h2><p>有时候，Bug 并不在于代码本身，而在于我们的思维方式。橡皮鸭调试法（Rubber Duck Debugging）是一种通过向&quot;橡皮鸭&quot;解释代码逻辑，从而发现和解决编程问题的调试方法。</p><h3 id="如何使用橡皮鸭调试法" tabindex="-1">如何使用橡皮鸭调试法： <a class="header-anchor" href="#如何使用橡皮鸭调试法" aria-label="Permalink to &quot;如何使用橡皮鸭调试法：&quot;">​</a></h3><ol><li>准备一个橡皮鸭（或者任何可以&quot;倾听&quot;你解释的对象）。</li><li>逐行向橡皮鸭解释你的代码逻辑，尽量详细地描述每一行代码的作用。</li><li>在解释的过程中，你可能会发现自己在某些地方卡住，或者意识到某些逻辑存在问题。</li><li>通过这种方式，你往往能够自己找到问题的根源。</li></ol><h3 id="为什么有效" tabindex="-1"><strong>为什么有效？</strong> <a class="header-anchor" href="#为什么有效" aria-label="Permalink to &quot;**为什么有效？**&quot;">​</a></h3><ul><li>语言化思考：将抽象思维转化为具体语言，能强制理清逻辑链条。</li><li>简化问题：避免陷入复杂的技术术语，回归问题本质。</li><li>打破思维定式：通过&quot;假装教学&quot;的视角，更容易发现盲点。</li></ul><p>橡皮鸭调试法的本质是：<strong>&quot;如果你不能向一个橡皮鸭解释清楚你的代码，那说明你还没真正理解它。&quot;</strong></p><h2 id="使用调试器" tabindex="-1">使用调试器 <a class="header-anchor" href="#使用调试器" aria-label="Permalink to &quot;使用调试器&quot;">​</a></h2><p>调试器是程序员最强大的工具之一，它允许你逐行执行代码，查看变量的值，设置断点，甚至可以在代码运行时修改变量的值。通过使用调试器，你可以高效地跟踪代码的执行过程，找到 Bug 的根源。</p><p>但在日常工作中经常看到很多人（以前的我也是）在每个可能出现的 bug 的地方添加各种日志，甚至手动修改一些代码进行调试。不仅导致混乱、效率低，而且还很容易忘记撤回修改的调试代码而导致更多的错误。</p><p>这里只简单的说下如何使用调试器（人人应该都会，只是强调多使用调试器进行 Debug，较少随意添加日志的行为）：</p><ol><li><strong>设置断点</strong>：在你认为可能出现问题的代码行上设置断点。</li><li><strong>逐行执行</strong>：启动调试器，逐行执行代码，观察每一步的执行结果。</li><li><strong>查看变量</strong>：在调试过程中，查看变量的值，确保它们符合预期。</li><li><strong>修改变量</strong>：在调试器中，你可以修改变量的值，测试不同的场景</li></ol><h2 id="番外" tabindex="-1">番外 <a class="header-anchor" href="#番外" aria-label="Permalink to &quot;番外&quot;">​</a></h2><p>如果调试时没有看到任何进展，请休息一下。有时，奇迹就会在休息、散步等瞬间的几秒钟内发生。</p>`,44),p=[t];function h(r,k,d,o,c,b){return i(),a("div",null,p)}const F=s(l,[["render",h]]);export{u as __pageData,F as default};
